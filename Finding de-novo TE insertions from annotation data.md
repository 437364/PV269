# Introduction
This project focuses on detecting novel repeat insertions within syntenic regions shared across a three-generation pedigree. We use high-quality genome assemblies from a proband (daughter), her mother, and both maternal grandparents to trace the inheritance of transposable elements (TEs). Specifically, we aim to identify _de novo_ TE insertions present in the proband but absent from the maternal lineage. Our analysis is limited to highly syntenic blocks, which helps control for large-scale structural variation. In addition, we examine the gaps between shared blocks to investigate whether TE insertions may disrupt synteny. Ultimately, this work seeks to develop a robust method for automated detection of novel TE insertions in closely related individuals. Such a method would complement existing approaches that analyze transposon dynamics over broader evolutionary timescales.

# Dataset description
Phased genome assemblies for grandmother, grandfather, mother, and daughter (proband) were provided as well as corresponding repeatome annotation track generated by RepeatMasker and shared syntenic blocks homologous between the generations. The basic problem is to find RepeatMasker annotations that are (1) present in the descendant's syntenic blocks but not in her ancestors'  or (2) present in the gaps between syntenic blocks of the descendants. Crucial aspects of these problems are to distiguish between true new annotations and mislabeled or mismatched annotations (1) and to determine whether the given gap between syntenic block has orginated by an insertion of a single element (2). 

# 1. Finding *de novo* insertions within blocks
## 1.1 Matching repeat annotations 
First, we extract the genomic coordinates of syntenic blocks and use them to filter repeat annotations present in the given block in the ancestors' and descendant's genome. This has been implemented using the pyranges package. Annotations were then filtered to only include transposons (filtering out satellites and low-complexity regions).  
Next, we match the annotations based on their order in the block, strand, and classification. For each repeat, RepeatMasker provides three hierarchical levels of classification, here referred to as Type, Family, and Name (with Name being the most granular). In case of perfect repeat annotation, mismatched candidates in the descendant's genome would represent *de novo* insertions. Annotation matching has been attempted in a pair-wise manner using a greedy (1.1 A) and alignment (1.1 B) approach.

### 1.1 A) Greedy approach 
The greedy approach compares the repeat annotations from the descendant (proband) and the grandparent sequentially, attempting to match repeats in the order they appear within a syntenic block. The matching is based on strand orientation and the second level of RepeatMasker classification (Family), since the Name class label has been often mismatched within otherwise perfectly matching annotations (e.g. MIR vs MIR3, L2c vs L2d). 
Starting with points on the first annotation of both proband and ancestor annotation lists, each proband annotation is matched to a specified number of ancestor's annotations starting from the pointer. If a match is found, ancestor pointer is advanced to avoid matching the repeat multiple times. If no match is found, proband annotation is written to the list of insertion candidates.

This method has identified insertion candidates on some syntenic blocks, but was unsuccessful on contigs where misalignments or mislabelings spans multiple annotations. Additionally, the number of downstream annotations checked for each proband repeat could not be increased, since this resulted in false matches due to insufficient specificity of repeat matching.  This method works well with consistent annotation and high-level synteny (which was expected given close relation between compared individuals). However, the repeat annotations are not conserved enough to avoid cascading mismatches.
[compare_blocks.ipynb](compare_blocks.ipynb)
### 1.1 B) Alignment approach
To overcome the limitations of the greedy method, we used global alignment, where local misalignment or partial mislabeling is less likely to disrupt the algorithm. First, important features for annotation matching are extracted and tokenized for matching function. Next, substitution matrix is calculated to tabulate the similarity score between all annotations. All three classification categories, strand, and annotation length contribute the similarity score, evading the previously observed mislabeling issue. Alignment is then found with traceback to maximize alignment score (accounting for gap penalty). Unmatched descendant annotations are then flagged as insertion candidates.
This method is substantially less time-efficient that the greedy approach and is highly dependent on the number of annotations in the block due to its quadratic complexity. This crucial disadvantage has been partially remedied by splitting large contigs into chunks and parallelized. In its current form, one pair-wise comparison took ~3h on 4 CPUs.

![[align_blocks.pdf]]

# Improvements and next steps
Candidate verification
Make it more modular to facilitate comparison between different genome pairs.
Improve alignment algorithm to make it more efficient
Add data analysis and visualization steps
