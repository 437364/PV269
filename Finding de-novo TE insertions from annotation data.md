# Introduction
This project focuses on detecting novel repeat insertions within syntenic regions shared across a three-generation pedigree. We use high-quality genome assemblies from a proband (daughter), her mother, and both maternal grandparents to trace the inheritance of transposable elements (TEs). Specifically, we aim to identify _de novo_ TE insertions present in the proband but absent from the maternal lineage. Our analysis is limited to highly syntenic blocks, which helps control for large-scale structural variation. In addition, we examine the gaps between shared blocks to investigate whether TE insertions may disrupt synteny. Ultimately, this work seeks to develop a robust method for automated detection of novel TE insertions in closely related individuals. Such a method would complement existing approaches that analyze transposon dynamics over broader evolutionary timescales.

# Dataset description
Phased genome assemblies for grandmother, grandfather, mother, and daughter (proband) were provided as well as corresponding repeatome annotation track generated by RepeatMasker and shared syntenic blocks homologous between the generations. The basic problem is to find RepeatMasker annotations that are (1) present in the descendant's syntenic blocks but not in her ancestors'  or (2) present in the gaps between syntenic blocks of the descendants. Crucial aspects of these problems are to distiguish between true new annotations and mislabeled or mismatched annotations (1) and to determine whether the given gap between syntenic block has orginated by an insertion of a single element (2). 

# 1. Finding *de novo* TE insertions within blocks
## Matching repeat annotations 
First, we extract the genomic coordinates of syntenic blocks and use them to filter repeat annotations present in the given block in the ancestors' and descendant's genome. This has been implemented using the pyranges package. Annotations were then filtered to only include transposons (filtering out simple repeats and low-complexity regions).  
Next, we match the annotations based on their order in the block, strand, and classification. For each repeat, RepeatMasker provides three hierarchical levels of classification, here referred to as Type, Family, and Name (with Name being the most granular). In case of perfect repeat annotation, mismatched candidates in the descendant's genome would represent *de novo* insertions. Annotation matching has been attempted in a pair-wise manner using a greedy (1.1 A) and alignment (1.1 B) approach.

### 1.1 Greedy approach 
The greedy approach compares the repeat annotations from the descendant (proband) and the grandparent sequentially, attempting to match repeats in the order they appear within a syntenic block. The matching is based on strand orientation and the second level of RepeatMasker classification (Family), since the Name class label has been often mismatched within otherwise perfectly matching annotations (e.g. MIR vs MIR3, L2c vs L2d). 
Starting with points on the first annotation of both proband and ancestor annotation lists, each proband annotation is matched to a specified number of ancestor's annotations starting from the pointer. If a match is found, ancestor pointer is advanced to avoid matching the repeat multiple times. If no match is found, proband annotation is written to the list of insertion candidates.

This method has identified insertion candidates on some syntenic blocks, but was unsuccessful on contigs where misalignments or mislabelings spans multiple annotations. Despite being relatively rare, occasional mismatches caused by annotation artifacts can break the linkage between the two lists and cause cascading mismatches. Additionally, the number of downstream annotations checked for each proband repeat could not be increased, since this resulted in false matches due to insufficient specificity of repeat matching. While this method works well with consistent annotation and high-level synteny (which was expected given close relation between compared individuals), the observed repeat annotations are not reliable enough to support this somewhat fragile approach.


Code: [compare_blocks.ipynb](compare_blocks.ipynb)

### 1.2 Alignment approach
To overcome the limitations of the greedy method, we used global alignment, where local misalignment or partial mislabeling is less likely to disrupt the algorithm. First, important features for annotation matching are extracted and tokenized for matching function. Next, substitution matrix is calculated to tabulate the similarity score between all annotations. All three classification categories, strand, and annotation length contribute the similarity score, evading the previously observed mislabeling issue. Alignment is then found with traceback to maximize alignment score (accounting for gap penalty). Unmatched descendant annotations are then flagged as insertion candidates.

This method is substantially less time-efficient that the greedy approach and highly dependent on the number of annotations in the block due to its quadratic time complexity. This crucial disadvantage has been partially remedied by splitting large contigs into chunks and parallelization. In its current form, one pair-wise comparison took ~3h on 4 CPUs.

While this alignment produces sensible output, there is still a large number of insertion candidates, likely due to imperfect RepeatMasker annotation (particularly of the LINE elements). The total number of candidates found is ~20 000, we expect only a couple of *de novo* insertions per generation.

<img src=https://github.com/437364/PV269/blob/main/insertions_by_type.png title="Alignment-based insertion candidate counts by transposon type"/>

It is therefore necessary to perform additional verification and processing steps on this candidate list to achieve reliable detection of *de novo* TE insertions. These are discussed in the last section.

Code: [align_blocks.ipynb](align_blocks.ipynb)

## 2. Finding *de novo* TE insertions between blocks
In addition to insertions within syntenic blocks, we also examined whether insertions of TEs could explain gaps between shared blocks in the proband's genome. This analysis focuses on identifying TEs that may have disrupted synteny and would not captured by within-block comparisons.

We first extracted shared syntenic blocks in the proband genome and constructed a BED file representing their genomic coordinates. These were then subtracted from the full chromosome lengths to identify regions not covered by shared synteny between generations (gaps).

Next, we selected only the maternal chromosomes (covered by gaps < 50%) and only the gaps that could have been plausibly caused by an insertion of a single element (size < 50 kb). This yielded ~2000 gaps in the proband's genome. To investigate whether these gaps could be explained by TEs, we intersected the filtered gaps with RepeatMasker annotations and evaluated how much of each gap was covered. We retained only those cases where a single family covered > 50 % of the gap and where > 80 % of the repeat annotation was contained within the gap. This filtering resulted in such 4 gaps/elements found, 1 hAT-Charlie element and 3 LINE elements. 
We attempted to manually verify one of the most promising hits, MER58B transposon from hAT-Charlie family. After visualizing the region of interest in grandmother (PAN010) and proband (PAN028) genome, it was clear that this hit does not represent *de novo* insertion.

<img src=https://github.com/437364/PV269/blob/main/block_gap_charlie.png title="hAT-Charlie synteny"/>

Code: [extract_bed.ipynb](extract_bed.ipynb)

# Improvements and next steps
## Candidate verification
As demonstrated in 1.1, insertion candidate number far exceeds the plausible expected number of insertions within two generations. To distinguish true *de novo* insertions from annotation artifacts, we suggest a verification step. This can be achieved by extracting candidate from descendant's genome and performing local BLAST against the general syntenic region in the ancestor's genome (defined as the boundary of flanking repeat annotations successfully matched to the descendant) to confirm its absence. Another option is to extract the region of interest from both genomes and align them or even to directly map raw reads from the ancestor to the proband genome assembly to verify insertion boundaries.
## Modularization and reusability
Since the current implementation of syntenic block alignment represents a preliminary exploration of relevant approaches, it is not suitable for systematic analysis of all genomes within the pedigree. The pipeline should be refactored and modularized to enable flexible comparisons of individuals and further improvements. Parametrization of variables and clear configuration of input genomes, annotation files, and block definitions would make the workflow more generalizable.
## Data integration and visualization
To gain insights about the insertion patterns, it is essential to include a method for characterizing and summarizing the results. Features such as repeat class, genomic position, and placement in the pedigree should be considered. 
